import XLSX from 'xlsx'
import SPL from 'spl.js'

// Generated by CoffeeScript 1.7.1
var createDb, db

async function onexec(e) {
    var data, buff
    data = e.data
    console.log(data.action)

    switch (data != null ? data['action'] : void 0) {
        case 'open':
            buff = data.buffer
            var array, isSQLite
            if (buff) {
                array = new Uint8Array(buff)
                isSQLite =
                    'SQLite format 3'.split('').every((k, i) => k.charCodeAt(0) == array[i]) &&
                    array[15] == 0
            }
            await createDb(isSQLite ? buff : void 0)
            if (buff && !isSQLite) {
                var str = Uint8ArrayToString(array)

                var json_list,
                    errors = []
                if (str.match(/\s*\[/)) {
                    // JSON list
                    try {
                        json_list = JSON.parse(str)
                    } catch (err) {
                        errors.push(err)
                    }
                } else if (str.match(/\s*\{/)) {
                    // JSONM
                    var tmp_list = []
                    str.split('\n').forEach((k) => {
                        try {
                            tmp_list.push(JSON.parse(k))
                        } catch (err) {
                            errors.push(err)
                        }
                    })
                    if (tmp_list.length > 0) {
                        json_list = tmp_list
                    }
                }
                if (json_list) {
                    var fields = {}
                    json_list.forEach((k) => Object.keys(k).forEach((j) => (fields[j] = true)))
                    var keys = Object.keys(fields)

                    async function run_stmt(x) {
                        console.log(x)
                        await db.read(x)
                    }

                    function escapeIdent(x) {
                        return '"' + (x + '').replace(/"/g, '""') + '"'
                    }
                    function escapeStr(x) {
                        return "'" + (x + '').replace(/'/g, "''") + "'"
                    }
                    var sname = data['sname'] || 'Sheet1'
                    await run_stmt('DROP TABLE IF EXISTS ' + escapeIdent(sname) + ';')
                    await run_stmt(
                        'CREATE TABLE ' +
                            escapeIdent(sname) +
                            ' (' +
                            keys.map((k) => `${escapeIdent(k)} TEXT`).join(', ') +
                            ');'
                    )

                    await json_list.forEach(async (k) => {
                        await run_stmt(
                            'INSERT INTO ' +
                                escapeIdent(sname) +
                                ' (' +
                                Object.keys(k)
                                    .map(escapeIdent)
                                    .join(', ') +
                                ') VALUES (' +
                                Object.values(k)
                                    .map(escapeStr)
                                    .join(',') +
                                ');'
                        )
                    })
                } else {
                    var not_sql = false
                    try {
                        await db.read(str)
                    } catch (err) {
                        console.log('Failed attempt to interpet as SQL: ' + err)
                        not_sql = true
                    }

                    if (not_sql) {
                        var wb = XLSX.read(str, { type: 'binary', cellDates: true })
                        wb.SheetNames.forEach(function(s) {
                            var sname = wb.SheetNames.length > 1 ? s : data['sname'] || s
                            prepforsexql(wb.Sheets[s], sname, db)
                        })
                    }
                }
            }
            return postMessage({
                id: data.id,
                ready: true,
            })
        case 'exec':
            const r = db.exec(data.sql).get
            const result = [
                {
                    columns: await r.cols,
                    values: await r.rows,
                },
            ]
            return postMessage({
                id: data.id,
                results: result,
            })
        case 'export':
            buff = await db.save()
            try {
                return postMessage(
                    {
                        id: data.id,
                        buffer: buff,
                    },
                    [buff]
                )
            } catch (_error) {
                err = _error
                return postMessage({
                    id: data.id,
                    buffer: buff,
                })
            }
            break
        case 'close':
            return db != null ? await db.close() : void 0
        default:
            throw new Error('Invalid action : '() + (data != null ? data.action : void 0))
    }
}

if (typeof importScripts === 'function') {
    db = null
    createDb = async function(data) {
        const spl = await SPL()
        if (db != null) {
            await db.close()
        }
        const projdb = await fetch('proj.db').then((response) => response.blob())
        db = await spl
            .mount(__dirname)
            .mount('proj', [
                // Mounts proj.db required for transformation to the default path (proj/proj.db) as remote db.
                // Instead of downloading the entire db spl/sqlite will only fetch required db pages.
                {
                    name: 'proj.db',
                    data: projdb,
                },
            ])
            .db(data)
            .exec('select enablegpkgamphibiousmode()')
        try {
            db = await db.exec('select initspatialmetadata(1)')
        } catch (err) {
            console.log(err)
        }
        return db
    }
    self.onmessage = function(e) {
        onexec(e)
    }
    self.addEventListener('unhandledrejection', function(event) {
        // the event object has two special properties:
        // event.promise - the promise that generated the error
        // event.reason  - the unhandled error object
        throw event.reason
    })
}

function arrayBufferToString(data) {
    var o = '',
        l = 0,
        w = 10240
    for (; l < data.byteLength / w; ++l)
        o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)))
    o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)))
    return o
}

function Uint8ArrayToString(data) {
    var arr = new Array()
    for (var i = 0; i != data.length; ++i) arr[i] = String.fromCharCode(data[i])
    return arr.join('')
}

// based on sheetjs.com/sexql/

async function log_and_exec(db, query) {
    console.log('query')
    try {
        await db.read(query)
    } catch (e) {
        console.error(e)
    }
}
async function prepforsexql(ws, sname, db) {
    /* Get sheet range */
    if (!ws || !ws['!ref']) return
    var range = XLSX.utils.decode_range(ws['!ref'])
    if (!range || !range.s || !range.e || range.s > range.e) return
    var R = range.s.r,
        C = range.s.c

    /* Generate headers */
    var names = new Array(range.e.c - range.s.c + 1)
    for (C = range.s.c; C <= range.e.c; ++C) {
        var addr = XLSX.utils.encode_cell({ c: C, r: R })
        names[C - range.s.c] = ws[addr] ? ws[addr].v : XLSX.utils.encode_col(C)
    }
    /* De-duplicate headers */
    for (var i = 0; i < names.length; ++i)
        if (names.indexOf(names[i]) < i)
            for (var j = 0; j < names.length; ++j) {
                var _name = names[i] + '_' + (j + 1)
                if (names.indexOf(_name) > -1) continue
                names[i] = _name
            }

    /* Guess column types */
    var types = new Array(range.e.c - range.s.c + 1)
    for (C = range.s.c; C <= range.e.c; ++C) {
        var seen = {},
            _type = ''
        for (R = range.s.r + 1; R <= range.e.r; ++R)
            seen[(ws[XLSX.utils.encode_cell({ c: C, r: R })] || { t: 'z' }).t] = true
        if (seen.s || seen.str) _type = 'TEXT'
        else if (seen.n + seen.b + seen.d + seen.e > 1) _type = 'TEXT'
        else
            switch (true) {
                case seen.b:
                case seen.n:
                    _type = 'REAL'
                    break
                case seen.e:
                    _type = 'TEXT'
                    break
                case seen.d:
                    _type = 'TEXT'
                    break
            }
        types[C - range.s.c] = _type || 'TEXT'
    }

    /* Create table */
    await log_and_exec(db, 'DROP TABLE IF EXISTS `' + sname + '`;')
    await log_and_exec(
        db,
        'CREATE TABLE `' +
            sname +
            '` (' +
            names
                .map(function(n, i) {
                    return '`' + n + '` ' + (types[i] || 'TEXT')
                })
                .join(', ') +
            ');'
    )

    /* Insert data */
    for (R = range.s.r + 1; R <= range.e.r; ++R) {
        var fields = [],
            values = []
        for (var C = range.s.c; C <= range.e.c; ++C) {
            var cell = ws[XLSX.utils.encode_cell({ c: C, r: R })]
            if (!cell) continue
            fields.push('`' + names[C - range.s.c] + '`')
            var val = cell.v
            switch (types[C - range.s.c]) {
                case 'REAL':
                    if (cell.t == 'b' || typeof val == 'boolean') val = +val
                    break
                default:
                    val = '"' + val.toString().replace(/"/g, '""') + '"'
            }
            values.push(val)
        }
        if (fields.length > 0)
            await log_and_exec(
                db,
                'INSERT INTO `' +
                    sname +
                    '` (' +
                    fields.join(', ') +
                    ') VALUES (' +
                    values.join(',') +
                    ');'
            )
    }
}
